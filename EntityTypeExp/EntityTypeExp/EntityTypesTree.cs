using System;
using System.Collections.Generic;
using System.Text;

namespace EntityTypeExp
{
    /// <summary>
    /// Представляет дерево классов
    /// </summary>
    public class EntityTypesTree
    {
        //Это должен быть основной класс данной темы с выражениями типов классов.
        //В нем нужно реализовать все практически применимые функции работы с классами для приложений.
        //Но я обычно делал в своих проектах более простые алгоритмы для более простых и ограниченных случаев.
        //А тут весь код надо писать практически заново, для поддержки всего, что когда-нибудь, возможно, потребуется.
 
        //Добавить функции дерева:
        
        //1. GetFullPath  Returns the absolute path for the specified path string.
        //- вернуть полный путь в цепочке классов 
        //- требует дерева классов
        
        //2. GetRandomName  Returns a random class name.
        //- Вернуть случайное название класса для использования в пакетном добавлении классов.
        //- понятия не имею, зачем это может пригодиться, если вся суть класса здесь заключается в его названии и еще - в его связях.
        //- но сделать можно, только это функция для дерева классов - только там можно определить, что название уникальное и не существует в дереве.
        //- требует дерева классов
        
        //3. Добавить выражение классов Сущности для пополнения Дерева классов.
        //- А) каждое вхождение класса представлено собственным объектом
        //- Проблема: это будет не дерево, а список ветвей.
        //- Б) все вхождения класса представлены единственным объектом.
        //- Проблема: тогда это уже не дерево получится, а граф.
        //- В) реализовать дерево, как оно сделано в браузере Хранилищ.
        //- код есть в материалах проекта?
        //- ТОДО: сформулировать способ построения такого дерева здесь 
        
        //4. Получить полную форму класса (с родительскими классами и агрегированными классами) по его названию.
        //- На входе: Транзистор На выходе: Предмет::Радиодеталь::Транзистор
        
        //5. Получить список корневых классов дерева 
        //- TODO: как массив названий или как массив объектов EntityType?
        
        //6. Получить последний класс иерархии в кратком имени
        //- это реализовать в классе EntityPath 
        
        //7. Получить ноду дерева - объект класса по его названию.
        //Получить объект класса EntityType по названию класса.
        //TODO: а если класс участвует внутри группы абстракции какого-то класса,
        //то в дереве может быть много его объектов. Какой объект вернуть?
        //- очевидно, тот, что участвует в цепочке абстракции - имеет надклассы.
        //Тут пробел в теории:
        //  Так как классы в группе агрегации не образуют цепочек абстракции, они только упоминаются, подобно ссылкам.
        //   то и представлять их объектами EntityType - избыточно. 
        //Очевидно, подклассы класса-контейнера должны наследовать его классы из группы абстракции, хоть они и не упоминаются в записи класса.
        //Но вот эта часть концепции пока не продумана мною, я занялся цепочкой абстракции как практической частью,
        //востребованной в проектах, а цепочку агрегации отложил на момент, когда в ней возникнет понятная необходимость.
        //Возможно, следует коллекцию подклассов агрегации в объектах EntityType заменить на коллекцию строк-названий подклассов?
        //Тогда в дереве будет (вроде бы ?) один объект класса, и этой функции возвращать придется только его.
        
        //8. Проверить, имеет ли класс с указанным названием подклассы в цепочке абстракции.
        //- это можно сделать только в дереве, так как объект класса EntityType не хранит ссылки на подклассы в цепочке абстракции.
        
        //9. Проверить, имеет ли класс с указанным названием подклассы агрегации - является ли контейнером.
        //- Это функция для класса EntityType, а в дереве можно реализовать обертку, 
        //  чтобы пользовательскому коду работать с деревом,
        //  и скрыть реализацию этого механизма для пользователя.
        
        //10. Проверить, является ли класс с указанным названием корнем дерева.
        //- проверить, содержит ли данный класс ссылку на какой-либо надкласс.
        //  Если нет, значит данный класс является корнем в дереве классов.
        //- Это функция для класса EntityType, а в дереве можно реализовать обертку, 
        //  чтобы пользовательскому коду работать с деревом,
        //  и скрыть реализацию этого механизма для пользователя.
        
        //11. Проверить, является ли класс с указанным названием листом дерева.
        //- Проверить, содержат ли другие классы в дереве ссылку на данный надкласс. Если нет ссылок, то данный класс является конечным узлом - листом дерева.
        
        //12.- Проверить, что класс является подклассом указанного класса-аргумента - по иерархии абстракции
        //- получить уровень глубины абстракции - целое число классов между двумя классами в цепочке иерархии.
        //  = 0: А = Б оба названия обозначают один и тот же класс
        //  = 1: А надкласс Б как А::Б
        //  = 2: А надкласс Б как А::Х::Б
        //  = -1: А подкласс Б как Б::А
        //  = -2:  А подкласс Б как Б::Х::А
        //  ... и так далее
        //TODO: а если между классами нет связи в цепочке абстракции, как это обозначать в возвращаемом результате функции?
        //- возвращать Double.Infinity ?
        
        //13.  проверить, что выражение не содержит нарушений структуры (имеет правильный формат)
        //- Это функция для классов EntityTypeExpression или EntityPath
        
        //14. - проверить, что указанное выражение записи цепочки классов уже есть в дереве классов.
        //- запись может содержать несколько классов, любой из которых, может оказаться, не присутствует в дереве.
        //  Поэтому результат Да-Нет тут не может быть использован.
        //Тут надо разделить цепочку на раздельные записи классов (по ;) и каждую проверять.
        
        //15. Вывести дерево классов в текстовый файл, в XML-файл.
        
        //16. Загрузить дерево классов из текстовый файла, из XML-файла.
        
        //17. Выполнить сложение (слияние) двух деревьев.
        //- Результатом должно стать новое дерево
        //  TODO: надо определить правила сложения двух деревьев.
        //- вероятно, по тому же принципу, что и добавление записей классов в джерево.
        
        //18. Выполнить вычитание двух деревьев.
        //- Результатом должно стать новое дерево
        // TODO: надо определить правила вычитания двух деревьев.

        //19. Для данных нескольких классов вернуть общий надкласс и пути от него до каждого из указанных классов.
        //- Это возможно, если все указанные классы имеют общий надкласс.
        //  TODO: А если это не так, то что делать?

        //20. Вычесть из полного пути класса путь от корня до указанного надкласса
        //- это чтобы вместо указания полного пути класса в таблице БД указывать только часть пути, относительно общего корня.
        //  Например, полный путь Предмет::Радиодеталь::Транзистор::ТранзисторБиполярный::ТранзисторБиполярныйPNP
        //указывать в таблице только ТранзисторБиполярный::ТранзисторБиполярныйPNP, 
        //А путь Предмет::Радиодеталь::Транзистор хранить отдельно и подставлять при необходимости.
        //- Эта функция для класса EntityPath. 

    }
}
