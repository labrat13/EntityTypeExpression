Новый список требований для этих классов:
- разбирать выражение записи класса на дерево по абстракции и агрегации.
- разбирать несколько записей классов, разделенных ; - на коллекцию классов.
- дать последний класс иерархии в кратком имени
- дать последний класс иерархии в полном виде (с родительскими классами и агрегированными классами)
- проверить, что класс является подклассом указанного класса-аргумента - по иерархии абстракции
  - получить уровень глубины абстракции - целое число классов между двумя классами в цепочке иерархии.
    = 0: А = Б
    = 1: А надкласс Б
    = -1: А подкласс Б
    ... и так далее
- проверить, что класс является надклассом указанного класса-аргумента - по иерархии абстракции
- проверить, что класс совпадает с указанным классом-аргументом.
- проверить, что запись класса не содержит нарушений структуры (имеет правильный формат)
- дать любой из классов в полном виде (собрать цепочку родительских классов из массива имен классов)
- собрать дерево классов из массива строк записей классов
  - А) каждое вхождение класса представлено собственным объектом
    - Проблема: это будет не дерево, а список ветвей.
  - Б) все вхождения класса представлены единственным объектом.
    - Проблема: тогда это уже не дерево получится, а граф.
  - В) реализовать дерево, как оно сделано в браузере Хранилищ.
    - ТОДО: сформулировать способ построения такого дерева здесь  
- проверить, что указанное выражение записи цепочки классов уже есть в дереве классов.
  - запись может содержать несколько классов, поэтому она может частично присутствовать в дереве.
    Поэтому результат Да-Нет тут не может быть использован.
- вывести дерево классов в текстовый файл, в XML-файл.     
- ...

Замечания:
- Класс EntityTypeExpression должен представлять запись типа, состоящую из цепочки классов. И предоставлять средства для работы с ними.
Это нужно для представления типа Сущности Хранилища в объекте Сущности.
- Класс EntityTypesCollection должен представлять список или массив объектов EntityType. И использоваться для построения дерева классов.
Подобного тому что уже есть в приложении поиска, но более детального и не в TreeView.
- Класс EntityTypesCollection может использоваться внутри EntityType для хранения списка надклассов абстракции и списка подклассов агрегации.
  Он должен иметь соответствующие функции для этого применения.
- Надо лучше проработать эту систему обозначения.
- Надо больше примеров. 
- Надо опыт использования.
- Операторы < > = можно ли использовать в иерархии? 
  - только внутри одной ветви классов. Соседняя ветвь уже не может так сравниваться.
- Проект SpeakInterface не использует классы толком - они используются для описания типа мест. А сами места впихиваются частично в аргументы и передаются исполняющей функции. Вот она и должна поверять эти типы мест. Но пока это не применяется, так как система еще не сложилась.

Состояние проекта:  
Сейчас это очень сырой код.
- Код написан только для класса и суперкласса или только для класса.
Более длинную ветвь нельзя указать.
- Агрегированные классы могут указываться только для последнего класса.
- Все отклонения от этого формата приводят к невозможности распарсить выражение.
- Формат выражения не проверяется.
- Код написан, исходя из того, что у каждого класса может быть несколько суперклассов.
  И вот они-то и записаны в словарь суперклассов. 
  Обычно он содержит ноль или один элемент - родительский класс, если он указан в записи.
  И эта штука предполагает что где-то есть общее дерево классов, из которого все эти классы можно найти по их уникальному имени.
  Так вот это такая непродуманная до конца конструкция, и я сейчас не знаю, как ее сделать даже.
  И во что переделать.  
Надо же так:
- каждый класс в цепочке абстракции может содержать запись агрегированных членов (<..>)
  - но классы внутри записи агрегации (между <>)не могут содержать агрегированные члены? Или могут?
- цепочка абстракции может содержать как минимум один класс и более.
- цепочка агрегации может содержать ноль класов и более. 
  