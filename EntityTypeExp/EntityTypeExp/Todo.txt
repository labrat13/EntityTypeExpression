Разметка в коде: Показывается в всплывающей подсказке IntelliSense студии, 
   позволяет избежать случаев "Уже использую, А я ее еще не сделал".
NR- Not Realized
NT- Not Tested
NFT- Not Fully Tested
RT- Ready Tested

Разметка здесь:
- пункт, задача или комментарий
+ выполненная задача.

28 ноября 2021 - Общий план проекта
Новый репозиторий наполнить и залить на гитхаб.
- классы из Оператора - для работы с классами Мест
  - желательно объединить в один класс, чтобы повторно использовать в проектах.
  - примеры использования функций в Операторе и МенеджереХранилищ.
- исправить теги документирования в классах.
- написать глоссарий для этой темы.  
- привести терминологию в проекте к единой системе.
  - позже, а то сейчас материалов в проекте много, все просматривать и переписывать неохота.
+ написать примеры выражений классов для тестов.  
  - файл ДобавитьПримерыВыраженийКлассов.txt
- написать тесты разбора выражений и сборки выражений
  - как примеры использования класса  
- текстовое описание формата выражений - в RTF или CHM.
  - справку по коду - в CHM
- собрать все классы в один файл для удобного использования в других проектах.
  - после релиза, а то отлаживать и изменять проект неудобно будет.
  - можно просто предложить потребителям самим объединить все в один файл, чтобы удобно использовать.   
- установить версию для этой единицы кода.
+ копирайт не забыть поставить.

29 ноября 2021
- разработать новую архитектуру для этого механизма - файл НовыйСписокТребований. 
- Цели классов сейчас:
  - EntityTypeExpression - строка классов для одной сущности, как сейчас в Хранилищах.
  - EntityTypesCollection - коллекция-список-словарь классов, представляет один уровень дерева классов.
  - EntityType - объект класса, представляет один узел в дереве классов.
  + ClassItem - устаревший комплексный класс, содержащий весь код по этой теме для Хранилищ.
    + перенести полезный код и удалить из проекта.
  - static EntityPath - статический класс для операций с иерархией абстракции в записях классов.
    - с функционалом подобно классу Path
    - работает только со строками записей классов.
  - EntityTypesTree - представляет дерево классов и содержит операции с ним.
    - основной класс-движок данной темы.
+ наполнить класс EntityPath функциями
  + выписать из класса Path функции
  + придумать как реализовать подобные функции в EntityPath
  + использовать код из ClassItem 
- переработать класс EntityType
  + заменить поля-словари на объекты EntityTypesCollection и новые функции для них.
  + изменить функции, используя новые классы EntityPath, итп.     
+ разделить класс ClassItem на:
  - static ClassPath с функционалом подобно классу Path.
  - функции парсера
  - функции построения дерева классов
+ спроектировать из этого набора классов новый класс записи классов EntityTypeExpression
  + определить набор функций для работ с записью классов одной Сущности, как сейчас в Хранилищах.
- осмотреть код в Материалы, определить, как можно реализовать его цели в текущем проекте.
  + определить цели для каждого из классов и описать здесь.
    - ClassItem - Представляет класс в системе Хранилищ - для Сущности и для Хранилища
      - класс представляет выражение и некоторые операции с ним. Ограничений для выражения много. 
    - LinkBuilder - класс конструктор ссылки на элемент хранилища по его квалифицированному имени.
      - квалифицированное имя это базовый класс для всех Сущностей Хранилища. 
        Такая же цепочка абстракции классов, только разделяется точкой вместо ::
        Позволяет выбирать правильное Хранилище для Сущностей и укорачивает строку записи класса Сущности в таблице БД.
    - LinkType - енум типа ссылки, используемый в LinkBuilder.
    - QualifiedNameManager - некоторые функции для работы с квалифицированными именами в ссылках на файлы.   
    - StorageSearcher - класс поиска в Хранилище. Полезен код построения дерева классов в TreeView, 
       но его что-то не понять мне самому. Хотя он работоспособен, строит дерево из общего списка классов из Хранилищ.
       Надо просто выбросить из класса все, что не относится к этой теме.
  + определить, уместно ли реализовать каждую из целей в текущем проекте.
    - класс, представляющий выражение и операции с ним: Зависит от приложения. Пользователь сам напишет такой для своих потребностей.
    - конструктор ссылки на Сущность: Зависит от приложения.  Пользователь сам напишет такой для своих потребностей.
    - Квалифицированное имя: Можно добавить позднее, если будет потребность. И там очень простая конвертация в/из цепочки абстракции классов.
    - поиск по классу: а он там не реализован. Только сборка дерева - как пример для класса EntityTypesTree.  
    + Вывод: помимо основной целей проекта, там больше ничего полезного и нет.
  - поставить задачи на написание кода.
  
06 декабря 2021
- Написать конечный автомат разбора и проверки правильности выражения, 
  в функции public static string[] EntityPath.Split(string classPath);
  или в классе EntityTypeExpression - для сложного выражения с множеством классов.
  - статический парсер - нехорошо в многопоточном приложении. 
    Следует в стеке размещать все переменные парсера или сделать его отдельным одноразовым объектом.
- определиться с коллекциями в классе EntityType
  + коллекция иерархии абстракции - надклассы или подклассы?
    - попробую подклассы в этот раз. Переделать позже, если не получится?
  - коллекция агрегации - объекты или названия классов?
    - самостоятельные объекты - единообразно.
    - строки - экономно.
    - классы в агрегации, по текущей концепции, не образуют явно связанной цепочки наследования агрегации. 
      Они просто там приведены как ссылки на классы. Их можно сейчас представить просто названиями, то есть, строками.
    - однако тему цепочки наследования агрегации надо позже прорабатывать.  
     
3:25 16.01.2022
- добавить варианты использования этого движка для тестирования минимального прототипа:
  Это нужно в проект тестирования перенести и там реализовать вызывающий код и описать алгоритмы.
  - тодо: переработать в правильные алгоритмы и варианты использования.
  - наполнение дерева классов:
    - из подготовленного файла извлекаются строки выражений по одной и добавляются в дерево. 
      Файл играет роль таблицы БД как источника записей выражений классов деталей.
  - создание нового выражения классов пользователем при добавлении записи о детали в БД:    
    - надо проверить, что введенное выражение является корректным выражением классов.
    - надо проверить, что имя нового класса уникальное, не присутствует в дереве классов.
    - надо проверить, что имя класса присутствует в дереве классов.
    - надо проверить, что выражение класса не противоречит строению дерева классов.
  - удаление класса из дерева - включает в себя удаление всех производных классов.
    Но у них тоже могут быть использующие их сущности в БД деталей. Это надо проверять.
    - надо получить список всех дочерних классов от указанного класса в дереве.
  - изменение данных класса
        - надо проверить, что введенное выражение является корректным выражением классов.
    - надо проверить, что имя нового класса уникальное, не присутствует в дереве классов.
    - надо проверить, что имя класса присутствует в дереве классов.
    - надо проверить, что выражение класса не противоречит строению дерева классов.
    - ?
  - просмотр данных класса и его дочерних классов.
    - ?

